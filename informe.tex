\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{parskip}

\usepackage[bottom]{footmisc}
\usepackage{titlesec}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{wrapfig}

\usepackage{mathtools}
\def\is{\coloneqq}

\usepackage{algorithm,algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage{caratula}

\begin{document}

\thispagestyle{empty}
\materia{Algoritmos y Estructuras de Datos III}
\submateria{Primer Cuatrimestre de 2019}
\titulo{Trabajo Práctico II}
\subtitulo{Modelando problemas con grafos}
\integrante{Ignacio Losiggio}{751/17}{iglosiggio@dc.uba.ar}
\integrante{Federico Sabatini}{579/17}{sabatinifedericoagustin@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents

\vspace{3cm}

\section{Segmentation is my fault}
\input{segmentation/informe/introduccion}
\input{segmentation/informe/informal}
\input{segmentation/informe/algoritmo}
\input{segmentation/informe/disjoint-set}
\input{segmentation/informe/imagenes-resultantes}
\input{segmentation/informe/conclusiones}


\section{Llenalo con super}

\subsection{Presentación del problema}
Dado un vendedor que cuenta con vehiculo propio que necesita moverse entre ciudades personalmente para vender sus productos, se quiere buscar la manera más económica de realizar la tarea.

Las distancias entre ciudades están representadas en kilometros y el costo de la nafta también es por kilometro luego se quiere minimizar el costo máximo de llegar de cada ciudad a todas las demás teniendo en cuenta las siguientes propiedades: 

\begin{enumerate}
	\item Las rutas que comunican las ciudades son bidireccionales.
	\item El precio de la nafta varía en cada ciudad.
	\item El auto posee un limite de nafta que puede cargar (máximo para 60 kilometros).
	\item El auto siempre empieza con el tanque vacio.
\end{enumerate}

Puede observarse que el problema es representable con grafos donde las ciudades $c_i$ son los vertices cada una con un costo de nafta $q_i$ asociado. Donde cada distancia $d_{x,y}$ que comunica un par de ciudades $(c_x, c_y)$ sin perdida de generalidad son las $m$ aristas del grafo. 

Además se denominará $l_i \in [0,60]$ como la cantidad de nafta cargada en una ciudad. 

Se representará entonces como un camino posible entre dos ciudades a $P_{k_{x,y}}$ en función del costo total en nafta de realizarlo. Nos interesa los caminos $P_{min_{x,y}}$ que cumplen:

$\forall(c_x, c_y \in Ciudades)(P_{min_{x,y}}, P_{k_{x,y}} \in Caminos(c_x,c_y))\rightarrow(P_{min} < P_k)$

Es decir nos interesan todos los caminos minimos.

Una motivación razonable para resolver el problema sería aplicar algoritmos de grafos conocidos de camino minimo, sin embargo nos encontramos con una serie de inconvenientes.

El costo de cargar nafta en una ciudad se encuentra en función de los vertices, no depende de las distancias, Sino de una multiplicación de $l_i$ por su respectivo precio $q_i$.

Las rutas son bidireccionales, sin embargo dadas 2 ciudades $c_a$ y $c_b$ no se cumple que los costes $c_a \rightarrow c_b$ y $c_b \rightarrow c_a$ sean iguales.

Eso significa que una representación direccional con digrafos podría resultar más adecuada para representar los costes efectivos. $Fig1, Fig2$ ilustran esta diferencia para 2 ciudades.

\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/direccional}.pdf}
	\captionof{figure}{bidireccional}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/bidireccional}.pdf}
	\captionof{figure}{direccional}
\end{minipage}

En particular $\forall(p_a \neq p_b) \rightarrow (p_a * d_{a,b} \neq p_b * d_{a,b}) $

Además los caminos minimos no necesariamente son simples, por ejemplo dadas 3 ciudades $c_a$, $c_b$ y $c_c$ y 2 rutas con distancia $d_{a,b}$ y $d_{a,c}$.

\begin{minipage}{0.5\textwidth}
	Tengo que si $q_a > q_b$ podría tener que evaluar si moverme allí para cargar nafta y volver es menos costoso, que ir directamente.
	
	En $Fig3$ se ilustra un grafo donde el costo de ir de $c_A$ a $c_c$ directamente es $p_a * d_{a,c} = 750$.
	
	Mientras que el camino pasando por $c_b$ son los costos asociados de ir de:
	
	$c_a \rightarrow c_b \rightarrow c_a \rightarrow c_c$ = 450.
	
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/caminoNoSimple}.pdf}
	\captionof{figure}{CaminoNoSimple}
\end{minipage}

Estas renstricciones aseguran que no es posible aplicar un algoritmo de camino minimo con la información del grafo original. Sin embargo en secciones posteriores analizaremos alternativas que nos permitan resolver el problema.


\subsubsection{Pautas de diseño}

El objetivo de este trabajo será entonces plantear transformaciones del grafo original que nos permitan aplicar algoritmos de camino minimo. Buscaremos establecer una cota de las dimensiones de nuestro nuevo grafo en función de la densidad y tamaño del grafo original.

Se someterá el grafo transformado a diferentes experimentos buscando comparar entre diferentes algoritmos de camino minimo cual de ellos se ajusta mejor. No explicaremos algoritmos de camino minimo como Dijkstra, Bellman-ford o Floyd-Warshall, se entienden por conocidos.

Finalmente Dijkstra, bellman-ford son algoritmos $1$ a $N$ (nodos), cuando nos refiramos a ellos como algoritmos $N$ a $N$, nos referimos justamente a ejecutarlos $N$ veces (Abordaremos este tema en detalle en secciones posteriores).

\subsubsection{En búsqueda de un algoritmo}

Dado un grafo $G$, se quiere obtener todos los caminos de costo total $P_{min}$ para cada $(c_i, c_j)$  empleando algoritmos de camino minimo, para esto se plantearán 2 funciones. La primera una funciòn $f(G) = G'$ que convierta nuestro grafo a un nuevo grafo en el cual se puedan aplicar algoritmos de camino minimo. Se obtendrá los resultados $R'$ de aplicar camino minimo a $G'$. Luego buscamos una función $g(R') = R$ que sepa interpretar los resultados de $G'$ y extraer los resultados reales de $G$ que nos interesan.

Dadas ambas funciones el algoritmo que aplicaremos sobre G para obtener los resultados R consta de los siguientes pasos:

\begin{enumerate}
	\item $G' \is f(G)$
	\item $R' \is$ Aplicar un algoritmo de camino minimo a $G'$
	\item $R \is g(R')$
\end{enumerate}

Hablaremos en detalle de los pasos (1) y (3), mientras que en el paso (2) solo haremos aclaraciones.

\subsubsection{Transformación del grafo $f(V)$}

Para aplicar camino minimo es necesario eliminar la noción del precio $q_i$ en función de los vertices, solo puede existir peso en las aristas. Además sería conveniente que el peso de las aristas resultantes de $G'$ representen costos, de ser así la $\sum d'_{x,y}$ representaría el costo total del camino $P$.  

Se sabe que la cantidad de litros de nafta que puede llevar nuestro vehiculo esta acotada por una constante $W$ de 60 litros. 

Debido a que W es acotado es razonable buscar que $f(V)$ dependa de esta constante, ya que la complejidad de dicha transformación sería $O(W * (n + m))$ el cual como $W$ es constante no afectaría la complejidad.

Es necesario redefinir entonces como será $V(G')$ y $E(G')$.

lo primero que haremos será multiplicar cara vertice $C_i$ por W estados posibles\footnote{Si $(W = 60)$ los estados son $61$, puedo estar en $C_i$ con: (0..60) lirtros de nafta.} entonces si:

$V$ posee  N nodos. 

$V'$ posee N * 61 tal que si $C_i$ es nodo en V $\rightarrow$ $\exists$ $\sum_{k=0}^{W} C'_{i * k}$ nodos en $V'$

por notación llamaremos $C'_{i_0}$ a $C'_{i_{60}}$ a nuestros vertices en $V'$ ahora bien necesitamos redefinir nuestras aristas en función del costo efectivo. Tendremos 2 tipos de aristas.

\begin{itemize}
	\item (1) que representa una arista de carga de combustible y comunica los $W$ estados de un nodo. Es razonable considerar que si yo estoy en una ciudad con k litros y quiero agregar un litro de nafta el costo será el precio de cargar nafta en dicha ciudad. Es trivial asumir que en general tendremos que dado un estado $C'_{i_k}$ el costo para ir a $C'_{i_{k+1}}$ será exactamente $p_i$ para toda $d_{k,k+1}$.
\end{itemize}

Es decir de nuestra transformaciòn tiene  $N * (W - 1$) aristas para movernos entre los estados $C'_{i_k}$

\begin{itemize}
	\item (2) que representa una arista de movimiento entre nodos $(C_A, C_B)$, en general por cada $d_{C_A,C_B} \in m$ de $V$ diremos que en $V'$ esto solo sucederá si se cumple que $C'_{A_k}$ $\exists$ $d'_{A_k,B_j}$ $\leftrightarrow$  $k - d_{A,B} = j$. Es decir ir de $C_A$ a $C_B$ solo es posible si la cantidad de litros con la que voy a llegar a B es la cantidad de litros que tenía en A menos la distancia. Y el costo de esta arista en particular es $0$ debido a que para que sea posible ya cargue combustible en A, lo que significa que ya pague el precio.
\end{itemize}

Con estas condiciones generamos $V'$, pero necesitamos comprobar si esta transformación es válida. Para ello nos alcanza con demostrar que los resultados $R$ de $V$ existen en $V'$ en particular nos alcanza con decir que $(R \subset R')$. Si esto sucede entonces $\exists$ $g(R')$ que transforma a $R$. No necesariamente trivial.

Imaginemos que existe costo efectivo minimo en $V$  $\exists costo_{min} \in (C_A,C_B)$ tal que no existe en $V'$.

De ser así existe una combinación de formas de cargar combustible en distintas $C_i$ tal que $\sum (p_i * l_i)$ no existe en $R'$ entonces existe alguna (o varias) formas de cargar combustible en una ciudad $(p_i * l_k)$ que no esta en $V'$

Sin embargo en $V'$ los W estados que representan un nodo son todas las formas de estar en una ciudad con $l_x$ litros previamente cargados.

Y agregar nuevos litros significa moverme entre los estados agregando para cada $C'_{i_k}$ el costo $p_i$ para ir al $C'_{i_{k+1}}$ es decir que agregar $l_k$ litros es $\sum_0^Y d'_{k,k+1}$ dado que $p_i$ = $d'_{k,k+1}$ es explicitamente $(l_k * p_i)$ para cualquier $l_k$ que mantenga el rango $W \in (0..61)$

Dado que $\forall (C'_{A_i}, C'_{B_j}) \exists d_{A_i,B_j}$ si se cumple el item \textbf{(2)} estoy representando todas las formas posibles de llegar a destino con $x$ combustible cargado mi estado inicial $C_A$ es $C'_{A_0}$\footnote{Es condición del problema que arranco con el tanque vacio.} y tengo todas las formas posibles de llegar a $C_{B}$ con (0..W) litros en el tanque, no perdi soluciones.

Sin embargo tengo soluciones de más, en particular tengo W formas distintas de llegar a $C_B$, y solo me interesa una. Abordaremos este tema en detalle cuando definamos $g(R')$. Una posible implementación del algoritmo sería:

\begin{algorithm}[H]
	\caption{$f(V)$}
	\begin{algorithmic}[1]
		\item[\textbf{Inicialización:}]
		\item[] \begin{itemize}
			\item[] $V_n = $ cantidad de nodos en V.
			\item[] $V_{aristas(i)} = $ tripla $(origen, destino, peso)$ de la i-esima arista.
			\item[] $W = 61$
		\end{itemize}
		\item[\textbf{Funciones auxiliares:}]
		\item[] \begin{itemize}
			\item[] \Call{AgregarArista}{$C_a,C_b,peso$} agrega $d_{C_a,C_b}$ al grafo $V'$
		\end{itemize}
		\Statex
		\Function{TransformarGrafo}{$V, n, m$}
		\State $V'_n \is V_n * W$
		\For{$(i \in (0..n))$}
		\Comment Aristas de carga de combustible
		\For{$(k \in (1..W))$}
		\State $C_{i_k} \is i * W + k$
		\State \Call{AgregarArista}{$C_{i_k} - 1,C_{i_k},peso$}
		\EndFor
		\EndFor
		\State
		
		\For{$(i \in (0..m))$}
		\State $C_a,C_b,d_{a,b} \is V_{aristas(i)}$
		\Comment Aristas de transición de nodos
		\For{$(k \in (1..W))$}
		\If{$k \geq d_{a,b}$}
		\Comment Agrego las aristas bidireccionalmente
		\State \Call{AgregarArista}{$C_a + k,C_b + k - d{a,b},0$}
		\State \Call{AgregarArista}{$C_b + k,C_a + k - d{a,b},0$}
		\EndIf
		\EndFor
		\EndFor
		
		\State \Return $V'$
		\EndFunction
	\end{algorithmic}
	\begin{description}
		\item[\textbf{Complejidad algorítmica:}] $O(W \times (n + m))$
	\end{description}
\end{algorithm}

\textbf{Nota}: Si bien es cierto que W es acotado, expreso la complejidad del algoritmo así para mostrar lo fuertemente dependiente que es del parámetro la transformación. 

A fines prácticos el algoritmo generá un ordenamiento en el cual los primeros $(0..60)$ nodos representan el nodo $0$ de $V$, los siguentes $(0..60)$ nodos al nodo $1$ de $V$ y así sucesivamente. El ordenamiento fue una desición de implementación. Sin embargo cualquier ordenamiento válido puede ser correcto, no necesariamente el aqui propuesto.

\subsubsection{como obtener los resultados de $V$ con $g(R')$}

Ahora podemos ejecutar algoritmos de camino minimo sobre $V'$ para obtener sus resultados. No nos interesa los detalles sobre como es la estructura de $R$ y $R'$, ya que los resultados son las distancias minimas entre 2 ciudades diremos que son una lista de tuplas $(origen, destino, costo)$

Sabemos que dado una ciudad de origen, su destino, esta representado por W nodos. Una idea intuitiva para pensar esto sería decir que dado un destino $C_b$ el costo minimo existe en alguno de sus $(C'_{b_0}...C'_{b_{60}})$ nodos. Entonces se puede calcular cual es el costo minimo a todos los estados posibles y nos quedamos solo con el minimo.

Sin embargo este calculo no es necesario, si definamos que significa un nodo en $V'$ sería estar en una ciudad $C_x$ con una cierta cantidad de litros. Ahora tomemos un nodo $C'_ {x_k}$ cualquiera con $(k \neq 0)$ Su distancia es minima debido a que se emplea un algoritmo de camino minimo y sobra $k$ de combustible.

la idea intuitiva que podemos asumir es que si tengo $k$ litros de sobra en mi tanque al llegar al destino, entonces existe un camino en el cual llego al destino sin pagar ese sobrante. Ese camino es justamente el camino minimo que va al destino con $k = 0$.   

Si consideramos el problema, solo nos interesa llegar al destino, no nos interesa llegar con un $k \neq 0$ cargado en el auto, ya que ese sobrante tiene un costo.

Entonces para obtener solo las distancias de $V'$ que representan a un costo minimo en el problema original solo nos interesan aquellos nodos de origen y destino que sean de la forma 
$C_{x_0}$ a $C_{y_0}$ con costo minimo.


\subsubsection{Sobre los algoritmos de camino minimo}

Todos los algoritmos reciben como parametro $V'$ como entrada con cualquier tipo de representación válida de un grafo (matriz, lista de adyacencia, etc), en el caso de los algoritmos $1$ a $n$ también necesitan que se le especifique el nodo de origen. Los outputs son siempre distancias al origen.

Costos algoritmos que citaremos:
\begin{itemize}
	\item Floyd Warshal. Algoritmo $n$ a $n$ $\rightarrow$  $O(n^3)$
	\item Bellman Ford. Algoritmo $1$ a $n$ $\rightarrow$ $O(n \times m)$
	\item Dijkstra. Algoritmo $1$ a $n$ $\rightarrow$ $O(n^2+m)$
	\item Dijkstra con prioridad. Algoritmo $1$ a $n$ $\rightarrow$  $O(m + log (n))$
\end{itemize}

Analizemos primero Floyd Warshall, por ser un algoritmo $n$ a $n$ este calcula todas las distancias a todos los origenes, esto generá que en su costo real al ejecutarse sobre $V'$ calcule las distancias de todos los origenes incluyendo estar en una ciudad con $k$ litros de nafta con $(k \neq 0)$. En teoría esto no afecta complejidad debido a que W es acotado.

Sin embargo en la práctica calculara $(C'_0..C'_W)$ origenes cuando lo que necesitamos es solo el $C'_0$ especificado en la sección anterior lo que podría implicar costes mayores (Ver experimentación para más detalles).

En el caso de los algoritmos $1$ a $n$ necesitamos transformarlos en algoritmos $n$ a $n$. Sin embargo tenemos espacio para optimizar, dado que solo nos interesan los caminos minimos que parten de un origen que implicitamente representa tener el tanque vacio. Podemos aprovechar y correrlo solo para los nodos que representen esa condición. Es decir todos los $C'{x_0}$ origenes y $C'{y_0}$ destinos

Realizada esta tarea los algoritmos de camino minimo $1$ a $n$ nodos, pasan a tener un grado más en su complejidad y ser algoritmos $n$ a $n$.

\subsubsection{Experimentación}

Reflejaremos como nuestra solución implementa diferentes algoritmos de camino minimo. Para esto someteremos cada algoritmo de camino minimo a una serie de experimentos.

Todos los experimentos que se realizarán cumplen las siguientes condiciones:
\begin{itemize}
	\item Los valores de cada prueba son generados aleatoriamente con distribución uniiforme.
	\item Cada grafo a probar es conexo es decir tiene minimo (n-1) aristas.
	\item Se repite cada prueba 25 veces. Se calcula el promedio.
	\item Se dispone de un tiempo límite de 20 segundos por cada prueba.
\end{itemize}

Además hay ciertos parámetros que serán inmutables durante la experimentación.

\begin{itemize}
	\item las Distancias entre ciudades viven entre $(0..60)$ (debido a que distancias mayores son imposibles de cruzar) 
	\item Los precios de combustible $p_i$ en cada ciudad viven entre $(100..200)$ la idea de que los precios no puedan variar más del doble es evitar que una ciudad posea un costo tan bajo que siempre se pase por ella.
\end{itemize}


Dicho anteriormente necesitamos comprobar si Floyd-Warshall es menos eficiente en la práctica. Una buena idea tomar grafos pequeños en $n$ y completos. En esta situación floyd warshall cuya complejidad es $O(n^3)$ no debería mostrar un comportamiento tan diferente contra algoritmos que dependan de $m$.

\begin{center}
	$n \in [3; 12]; m=\frac{n*(n - 1)}{2}$
\end{center}

\includegraphics[width=\linewidth]{{graficos/expB_algos_todos}.pdf}
\captionof{figure}{Comparación de los algoritmos}

\vspace{5mm}
Notar que floyd warshall tarda un tiempo considerablemente mayor. Algo que podríamos pensar es que los algoritmos viven en complejidades diferentes, y representarlos en un gráfico de correlación para comprobarlo.

Se supone que por ser completo $O(m)=O(n^2)$ podemos chequear que en todos los casos ya que $n$ es completo el fit sea decente para $n^3$

\begin{center}
\includegraphics[width=\linewidth]{{graficos/bellman_ford_correlacion}.pdf}
\captionof{figure}{Bellman Ford}
\includegraphics[width=\linewidth]{{graficos/dijkstra_correlacion}.pdf}
\captionof{figure}{Dijkstra}
\includegraphics[width=\linewidth]{{graficos/pq_dijkstra_correlacion}.pdf}
\captionof{figure}{Dijkstra con prioridad}
\includegraphics[width=\linewidth]{{graficos/floyd_warshall_correlacion}.pdf}
\captionof{figure}{Floyd Warshall}
\end{center}

\newpage

El primer experimento resultó muy pequeño para mostrar el comportamiento de los algoritmos de Dijkstra, Bellman Ford y Dijkstra con prioridad.

Decidimos realizar un nuevo experimento para ver sus comportamientos cuando $v$ es poco denso, para esto decidimos tomar $n$ mucho más grande.
\vspace{5mm}
\begin{center}
	$n \in [10; 100]; m=(n*3)$
\end{center}

\includegraphics[width=\linewidth]{{graficos/expA_algos_todos}.pdf}
\captionof{figure}{Comparación de algoritmos (Excluido Floyd Warshall)}

\vspace{5mm}

Nota: En este último experimento, Dijkstra al llegar a $n = 60$ se excedió del tiempo límite marcado. 

Finalmente como podemos observar Dijkstra con prioridad y Bellman Ford muestra una velocidad superior al resto.

\newpage

\subsubsection{Trabajo Futuro de esta sección}

En un principio teniamos planteadas un scope mucho más grande con el proyecto, sin embargo por limitaciones del tiempo no hemos podido cubrir todo lo que en un principio nos propusimos. Esta es solo una lista de cosas que consideramos nos faltaron.

\begin{enumerate}
	\item En el problema de camino minimo en un principio habíamos realizado otra transformación del grafo diferente a la propuesta en este informe. Dicha transformación era más densa. Sin embargo habría estado bueno realizar una experimentación con ambas transformaciones y analizar si Bellman Ford o Dijkstra con prioridad realizaban una elección de aristas mejor que les permita tener mejor rendimiento.
	
	\item Nos hubierá gustado definir una experimentación constante en $n$ suficientemente grande que varia en las aristas, para así revisar fijado un $n$ como los algoritmos manejan la densidad.
	
	\item En el primer experimento, $n \in [3; 12]$ nos hubierá gustado tomar un $n$ más grande sin embargo lo elegimos así por su practicidad para realizar una experimentación rapida.
\end{enumerate}









\end{document}
