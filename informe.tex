\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{parskip}

\usepackage[bottom]{footmisc}
\usepackage{titlesec}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{wrapfig}

\usepackage{mathtools}
\def\is{\coloneqq}

\usepackage{algorithm,algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage{caratula}

\begin{document}

\thispagestyle{empty}
\materia{Algoritmos y Estructuras de Datos III}
\submateria{Primer Cuatrimestre de 2019}
\titulo{Trabajo Práctico II}
\subtitulo{Modelando problemas con grafos}
\integrante{Ignacio Losiggio}{751/17}{iglosiggio@dc.uba.ar}
\integrante{Federico Sabatini}{579/17}{sabatinifedericoagustin@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents

\vspace{3cm}

\section{Segmentation is my fault}
\input{segmentation/informe/introduccion}
\input{segmentation/informe/informal}
\input{segmentation/informe/algoritmo}
\input{segmentation/informe/disjoint-set}
\input{segmentation/informe/imagenes-resultantes}
\input{segmentation/informe/conclusiones}


\section{Llenalo con super}

\subsection{Presentación informal del problema}
Dado un vendedor que cuenta con vehiculo propio que necesita moverse entre ciudades personalmente para vender sus productos, quiere buscar la manera más económica de realizar la tarea.

Si la distancias entre ciudades estan representadas en kilometros y el precio de la nafta es por litro queremos minimizar el costo en nafta de llegar de cada ciudad a las demas teniendo en cuenta las siguientes propiedades: 

\begin{enumerate}
	\item Las rutas que comunican las ciudades son bidireccionales.
	\item El precio de la nafta varia de ciudad en ciudad.
	\item El auto posee un limite de litros de nafta que puede cargar (60 litros).
	\item Se estima que cada litro de nafta alcanza para exactamente un kilometro de distancia.
	\item El auto siempre empieza descargado (Con 0 litros de combustible).
\end{enumerate}

El problema formalmente será representado como un grafo donde cada ciudad $c_i$ es un vertice con su respectivo precio por litro $p_i$ y donde cada distancia $d_{x,y}$ que comunica un par de ciudades ($c_x, c_y$) son las $m$ aristas del grafo.

Representado el $r_k$ como un camino posible entre dos ciudades en función del costo efectivo comprendido como la cantidad de litros $l_i$ que cargue de nafta por su respectivo precio $p_i$ queremos los caminos que cumplen que:

$\forall(c_x, c_y \in Ciudades)(r_{m}, r_k \in Caminos(c_x,c_y))\rightarrow(r_{m} < r_k)$

Es decir nos interesan todos los caminos minimos.

Una motivación razonable para resolver el problema sería entonces simplemente aplicar algoritmos conocidos de camino minimo, sin embargo esto no es posible con el grafo original.

Para empezar el precio al estar en función de los vertices, los costes no dependen solo de las distancias, sino de una multiplicación entre litros cargados por el precio.

Las rutas son bidireccionales, sin embargo dadas 2 ciudades $C_a$ y $C_b$ no se cumple que los costes $C_a \rightarrow C_b$ y $C_b \rightarrow C_a$ sean iguales.

Eso significa que necesitariamos una representación direccional si quisieramos hablar de costes efectivos. $Fig1, Fig2$ ilustran esta diferencia para 2 ciudades.

\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/bidireccional}.pdf}
	\captionof{figure}{bidireccional}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/direccional}.pdf}
	\captionof{figure}{direccional}
\end{minipage}

En particular $\forall(p_a \neq p_b) \rightarrow (p_a * d_{a,b} \neq p_b * d_{a,b}) $

Además los caminos minimos no necesariamente son simples, por ejemplo dadas 3 ciudades $C_a$, $C_b$ y $C_c$ y 2 rutas con distancia $d_{a,b}$ y $d_{a,c}$.

\begin{minipage}{0.5\textwidth}
	Tengo que si $p_a > p_b$ podría tener que evaluar si moverme allí para cargar nafta y volver es menos costoso, que ir directamente.
	
	En fig3 se ilustra un grafo donde el costo de ir de $C_A$ a $C_C$ directamente es $p_a * d_{a,c} = 750$.
	
	Mientras que el camino pasando por $C_b$ es:
	
	$C_a$ a $C_b$ a $C_a$ a $C_C$ = 450.
	
	Sin embargo esto motiva a analizar si existen transformaciones del grafo en la que aplicar algoritmos de camino minimo es posible.
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\includegraphics[width=\linewidth]{{graficos/caminoNoSimple}.pdf}
	\captionof{figure}{CaminoNoSimple}
\end{minipage}


\subsubsection{Pautas de diseño}

El objetivo de este trabajo es plantear transformaciones de grafos que nos permitan aplicar algoritmos de camino minimo. Buscaremos establecer una cota de las dimensiones de nuestro nuevo grafo en función de la densidad y tamaño del grafo original.

Someteremos nuestro grafo a diferentes experimentos buscando comparar entre diferentes algoritmos de camino minimo cual de ellos se ajusta mejor. No explicaremos algoritmos de camino minimo como Dijkstra, Bellman-ford o Floyd-Warshall, se entienden por conocidos.

Finalmente Dijkstra, bellman-ford son algoritmos $1$ a $N$ (nodos), cuando nos refiramos a ellos como algoritmos $N$ a $N$, nos referimos justamente a ejecutarlos $N$ veces (Abordaremos este tema en detalle en secciones posteriores).

\subsubsection{En búsqueda de un algoritmo}

Buscamos dado un grafo $V$, obtener todos sus costos efectivos minimos $R$ para cada $(C_i, C_j)$ y ádemas queremos realizar dicha tarea empleando algoritmos de camino minimo, para esto se plantearán 2 funciones. La primera una funciòn $f(V) = V'$ que convierta nuestro grafo en función del costo efectivo a un nuevo grafo en el cual si se puedan aplicar algoritmos de camino minimo. Luego buscamos una función $g(R') = R$ que sepa interpretar los resultados del nuevo grafo como solución del original y obtener los resultados de $V$ que nos interesan.

Dadas ambas funciones el algoritmo que aplicaremos sobre V para obtener los resultados R consta de los siguientes pasos:

\begin{enumerate}
	\item $V' \is f(V)$
	\item $R' \is$ Aplicar un algoritmo de camino minimo a $V'$
	\item $R \is g(R')$
\end{enumerate}

Hablaremos en detalle de los pasos (1) y (3), mientras que en el paso (2) solo haremos aclaraciones.

\subsubsection{Transformación del grafo $f(V)$}

Para lograr esta tarea, necesitamos eliminar la noción del precio ya que los algoritmos de camino minimo solo saben operar en funciòn del peso de las aristas. Además paso las aristas resultantes que debemos obtener serìa conveniente que esten en función del costo efectivo.

Sabemos además que la cantidad de litros de nafta que puede llevar nuestro vehiculo esta acotada por una constante llamemos $W$ de 60 litros. 

Debido a que W es acotado una estrategia razonable sería lograr que $f(V)$ dependa de esta constante, ya que la complejidad de un algoritmo de camino minimo $N$ a $N$ es $O(n^3)$, si incluimos el costo de la transformación sería $O(W * n^3)$ y si $W$ es constante no influiría en nuestra complejidad.

Empezemos por redefinir los vertices, en $V'$ no puedo tener estados, no puedo estar en una ciudad $C_i$ con $X$ de nafta, y un precio $p_i$ para agregar litros.

Lo primero que haremos será multiplicar cara vertice $C_i$ por W estados posibles\footnote{Si $(W = 60)$ los estados son $61$, puedo estar en $C_i$ con: (0..60) lirtros de nafta.} entonces si:

$V$ posee  N nodos. 

$V'$ posee N * 61 tal que si $C_i$ es nodo en V $\rightarrow$ $\exists$ $\sum_{k=0}^{W} C'_{i * k}$ nodos en $V'$

por notación llamaremos $C'_{i_0}$ a $C'_{i_{60}}$ a nuestros vertices en $V'$ ahora bien necesitamos redefinir nuestras aristas en función del costo efectivo. Tendremos 2 tipos de aristas.

\begin{itemize}
	\item (1) que representa una arista de carga de combustible y comunica los $W$ estados de un nodo. Es razonable considerar que si yo estoy en una ciudad con k litros y quiero agregar un litro de nafta el costo será el precio de cargar nafta en dicha ciudad. Es trivial asumir que en general tendremos que dado un estado $C'_{i_k}$ el costo para ir a $C'_{i_{k+1}}$ será exactamente $p_i$ para toda $d_{k,k+1}$.
\end{itemize}

Es decir de nuestra transformaciòn tiene  $N * (W - 1$) aristas para movernos entre los estados $C'_{i_k}$

\begin{itemize}
	\item (2) que representa una arista de movimiento entre nodos $(C_A, C_B)$, en general por cada $d_{C_A,C_B} \in m$ de $V$ diremos que en $V'$ esto solo sucederá si se cumple que $C'_{A_k}$ $\exists$ $d'_{A_k,B_j}$ $\leftrightarrow$  $k - d_{A,B} = j$. Es decir ir de $C_A$ a $C_B$ solo es posible si la cantidad de litros con la que voy a llegar a B es la cantidad de litros que tenía en A menos la distancia. Y el costo de esta arista en particular es $0$ debido a que para que sea posible ya cargue combustible en A, lo que significa que ya pague el precio.
\end{itemize}

Con estas condiciones generamos $V'$, pero necesitamos comprobar si esta transformación es válida. Para ello nos alcanza con demostrar que los resultados $R$ de $V$ existen en $V'$ en particular nos alcanza con decir que $(R \subset R')$. Si esto sucede entonces $\exists$ $g(R')$ que transforma a $R$. No necesariamente trivial.

Imaginemos que existe costo efectivo minimo en $V$  $\exists costo_{min} \in (C_A,C_B)$ tal que no existe en $V'$.

De ser así existe una combinación de formas de cargar combustible en distintas $C_i$ tal que $\sum (p_i * l_i)$ no existe en $R'$ entonces existe alguna (o varias) formas de cargar combustible en una ciudad $(p_i * l_k)$ que no esta en $V'$

Sin embargo en $V'$ los W estados que representan un nodo son todas las formas de estar en una ciudad con $l_x$ litros previamente cargados.

Y agregar nuevos litros significa moverme entre los estados agregando para cada $C'_{i_k}$ el costo $p_i$ para ir al $C'_{i_{k+1}}$ es decir que agregar $l_k$ litros es $\sum_0^Y d'_{k,k+1}$ dado que $p_i$ = $d'_{k,k+1}$ es explicitamente $(l_k * p_i)$ para cualquier $l_k$ que mantenga el rango $W \in (0..61)$

Dado que $\forall (C'_{A_i}, C'_{B_j}) \exists d_{A_i,B_j}$ si se cumple el item \textbf{(2)} estoy representando todas las formas posibles de llegar a destino con $x$ combustible cargado mi estado inicial $C_A$ es $C'_{A_0}$\footnote{Es condición del problema que arranco con el tanque vacio.} y tengo todas las formas posibles de llegar a $C_{B}$ con (0..W) litros en el tanque, no perdi soluciones.

Sin embargo tengo soluciones de más, en particular tengo W formas distintas de llegar a $C_B$, y solo me interesa una. Abordaremos este tema en detalle cuando definamos $g(R')$. Una posible implementación del algoritmo sería:

\begin{algorithm}[H]
	\caption{$f(V)$}
	\begin{algorithmic}[1]
		\item[\textbf{Inicialización:}]
		\item[] \begin{itemize}
			\item[] $V_n = $ cantidad de nodos en V.
			\item[] $V_{aristas(i)} = $ tripla $(origen, destino, peso)$ de la i-esima arista.
			\item[] $W = 61$
		\end{itemize}
		\item[\textbf{Funciones auxiliares:}]
		\item[] \begin{itemize}
			\item[] \Call{AgregarArista}{$C_a,C_b,peso$} agrega $d_{C_a,C_b}$ al grafo $V'$
		\end{itemize}
		\Statex
		\Function{TransformarGrafo}{$V, n, m$}
		\State $V'_n \is V_n * W$
		\For{$(i \in (0..n))$}
		\Comment Aristas de carga de combustible
		\For{$(k \in (1..W))$}
		\State $C_{i_k} \is i * W + k$
		\State \Call{AgregarArista}{$C_{i_k} - 1,C_{i_k},peso$}
		\EndFor
		\EndFor
		\State
		
		\For{$(i \in (0..m))$}
		\State $C_a,C_b,d_{a,b} \is V_{aristas(i)}$
		\Comment Aristas de transición de nodos
		\For{$(k \in (1..W))$}
		\If{$k \geq d_{a,b}$}
		\Comment Agrego las aristas bidireccionalmente
		\State \Call{AgregarArista}{$C_a + k,C_b + k - d{a,b},0$}
		\State \Call{AgregarArista}{$C_b + k,C_a + k - d{a,b},0$}
		\EndIf
		\EndFor
		\EndFor
		
		\State \Return $V'$
		\EndFunction
	\end{algorithmic}
	\begin{description}
		\item[\textbf{Complejidad algorítmica:}] $O(W \times (n + m))$
	\end{description}
\end{algorithm}

\textbf{Nota}: Si bien es cierto que W es acotado, expreso la complejidad del algoritmo así para mostrar lo fuertemente dependiente que es del parámetro la transformación. 

A fines prácticos el algoritmo generá un ordenamiento en el cual los primeros $(0..60)$ nodos representan el nodo $0$ de $V$, los siguentes $(0..60)$ nodos al nodo $1$ de $V$ y así sucesivamente. El ordenamiento fue una desición de implementación. Sin embargo cualquier ordenamiento válido puede ser correcto, no necesariamente el aqui propuesto.

\subsubsection{como obtener los resultados de $V$ con $g(R')$}

Ahora podemos ejecutar algoritmos de camino minimo sobre $V'$ para obtener sus resultados. No nos interesa los detalles sobre como es la estructura de $R$ y $R'$, ya que los resultados son las distancias minimas entre 2 ciudades diremos que son una lista de tuplas $(origen, destino, costo)$

Sabemos que dado una ciudad de origen, su destino, esta representado por W nodos. Una idea intuitiva para pensar esto sería decir que dado un destino $C_b$ el costo minimo existe en alguno de sus $(C'_{b_0}...C'_{b_{60}})$ nodos. Entonces se puede calcular cual es el costo minimo a todos los estados posibles y nos quedamos solo con el minimo.

Sin embargo este calculo no es necesario, si definamos que significa un nodo en $V'$ sería estar en una ciudad $C_x$ con una cierta cantidad de litros. Ahora tomemos un nodo $C'_ {x_k}$ cualquiera con $(k \neq 0)$ Su distancia es minima debido a que se emplea un algoritmo de camino minimo y sobra $k$ de combustible.

la idea intuitiva que podemos asumir es que si tengo $k$ litros de sobra en mi tanque al llegar al destino, entonces existe un camino en el cual llego al destino sin pagar ese sobrante. Ese camino es justamente el camino minimo que va al destino con $k = 0$.   

Si consideramos el problema, solo nos interesa llegar al destino, no nos interesa llegar con un $k \neq 0$ cargado en el auto, ya que ese sobrante tiene un costo.

Entonces para obtener solo las distancias de $V'$ que representan a un costo minimo en el problema original solo nos interesan aquellos nodos de origen y destino que sean de la forma 
$C_{x_0}$ a $C_{y_0}$ con costo minimo.


\subsubsection{Sobre los algoritmos de camino minimo}

Todos los algoritmos reciben como parametro $V'$ como entrada con cualquier tipo de representación válida de un grafo (matriz, lista de adyacencia, etc), en el caso de los algoritmos $1$ a $n$ también necesitan que se le especifique el nodo de origen. Los outputs son siempre distancias al origen.

Costos algoritmos que citaremos:
\begin{itemize}
	\item Floyd Warshal. Algoritmo $n$ a $n$ $\rightarrow$  $O(n^3)$
	\item Bellman Ford. Algoritmo $1$ a $n$ $\rightarrow$ $O(n \times m)$
	\item Dijkstra. Algoritmo $1$ a $n$ $\rightarrow$ $O(n^2+m)$
	\item Dijkstra con prioridad. Algoritmo $1$ a $n$ $\rightarrow$  $O(m + log (n))$
\end{itemize}

Analizemos primero Floyd Warshall, por ser un algoritmo $n$ a $n$ este calcula todas las distancias a todos los origenes, esto generá que en su costo real al ejecutarse sobre $V'$ calcule las distancias de todos los origenes incluyendo estar en una ciudad con $k$ litros de nafta con $(k \neq 0)$. En teoría esto no afecta complejidad debido a que W es acotado.

Sin embargo en la práctica calculara $(C'_0..C'_W)$ origenes cuando lo que necesitamos es solo el $C'_0$ especificado en la sección anterior lo que podría implicar costes mayores (Ver experimentación para más detalles).

En el caso de los algoritmos $1$ a $n$ necesitamos transformarlos en algoritmos $n$ a $n$. Sin embargo tenemos espacio para optimizar, dado que solo nos interesan los caminos minimos que parten de un origen que implicitamente representa tener el tanque vacio. Podemos aprovechar y correrlo solo para los nodos que representen esa condición. Es decir todos los $C'{x_0}$ origenes y $C'{y_0}$ destinos

Realizada esta tarea los algoritmos de camino minimo $1$ a $n$ nodos, pasan a tener un grado más en su complejidad y ser algoritmos $n$ a $n$.

\subsubsection{Experimentación}

Reflejaremos como nuestra solución implementa diferentes algoritmos de camino minimo. Para esto someteremos cada algoritmo de camino minimo a una serie de experimentos.

Todos los experimentos que se realizarán cumplen las siguientes condiciones:
\begin{itemize}
	\item Los valores de cada prueba son generados aleatoriamente con distribución uniiforme.
	\item Cada grafo a probar es conexo es decir tiene minimo (n-1) aristas.
	\item Se repite cada prueba 25 veces. Se calcula el promedio.
	\item Se dispone de un tiempo límite de 20 segundos por cada prueba.
\end{itemize}

Además hay ciertos parámetros que serán inmutables durante la experimentación.

\begin{itemize}
	\item las Distancias entre ciudades viven entre $(0..60)$ (debido a que distancias mayores son imposibles de cruzar) 
	\item Los precios de combustible $p_i$ en cada ciudad viven entre $(100..200)$ la idea de que los precios no puedan variar más del doble es evitar que una ciudad posea un costo tan bajo que siempre se pase por ella.
\end{itemize}


Dicho anteriormente necesitamos comprobar si Floyd-Warshall es menos eficiente en la práctica. Una buena idea tomar grafos pequeños en $n$ y completos. En esta situación floyd warshall cuya complejidad es $O(n^3)$ no debería mostrar un comportamiento tan diferente contra algoritmos que dependan de $m$.

\begin{center}
	$n \in [3; 12]; m=\frac{n*(n - 1)}{2}$
\end{center}

\includegraphics[width=\linewidth]{{graficos/expB_algos_todos}.pdf}
\captionof{figure}{Comparación de los algoritmos}

\vspace{5mm}
Notar que floyd warshall tarda un tiempo considerablemente mayor. Algo que podríamos pensar es que los algoritmos viven en complejidades diferentes, y representarlos en un gráfico de correlación para comprobarlo.

Se supone que por ser completo $O(m)=O(n^2)$ podemos chequear que en todos los casos ya que $n$ es completo el fit sea decente para $n^3$

\begin{center}
\includegraphics[width=\linewidth]{{graficos/bellman_ford_correlacion}.pdf}
\captionof{figure}{Bellman Ford}
\includegraphics[width=\linewidth]{{graficos/dijkstra_correlacion}.pdf}
\captionof{figure}{Dijkstra}
\includegraphics[width=\linewidth]{{graficos/pq_dijkstra_correlacion}.pdf}
\captionof{figure}{Dijkstra con prioridad}
\includegraphics[width=\linewidth]{{graficos/floyd_warshall_correlacion}.pdf}
\captionof{figure}{Floyd Warshall}
\end{center}

\newpage

El primer experimento resultó muy pequeño para mostrar el comportamiento de los algoritmos de Dijkstra, Bellman Ford y Dijkstra con prioridad.

Decidimos realizar un nuevo experimento para ver sus comportamientos cuando $v$ es poco denso, para esto decidimos tomar $n$ mucho más grande.
\vspace{5mm}
\begin{center}
	$n \in [10; 100]; m=(n*3)$
\end{center}

\includegraphics[width=\linewidth]{{graficos/expA_algos_todos}.pdf}
\captionof{figure}{Comparación de algoritmos (Excluido Floyd Warshall)}

\vspace{5mm}

Nota: En este último experimento, Dijkstra al llegar a $n = 60$ se excedió del tiempo límite marcado. 

Finalmente como podemos observar Dijkstra con prioridad y Bellman Ford muestra una velocidad superior al resto.

\newpage

\subsubsection{Trabajo Futuro de esta sección}

En un principio teniamos planteadas un scope mucho más grande con el proyecto, sin embargo por limitaciones del tiempo no hemos podido cubrir todo lo que en un principio nos propusimos. Esta es solo una lista de cosas que consideramos nos faltaron.

\begin{enumerate}
	\item En el problema de camino minimo en un principio habíamos realizado otra transformación del grafo diferente a la propuesta en este informe. Dicha transformación era más densa. Sin embargo habría estado bueno realizar una experimentación con ambas transformaciones y analizar si Bellman Ford o Dijkstra con prioridad realizaban una elección de aristas mejor que les permita tener mejor rendimiento.
	
	\item Nos hubierá gustado definir una experimentación constante en $n$ suficientemente grande que varia en las aristas, para así revisar fijado un $n$ como los algoritmos manejan la densidad.
	
	\item En el primer experimento, $n \in [3; 12]$ nos hubierá gustado tomar un $n$ más grande sin embargo lo elegimos así por su practicidad para realizar una experimentación rapida.
\end{enumerate}









\end{document}
